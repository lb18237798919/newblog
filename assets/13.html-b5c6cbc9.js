import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as i,c as r,e as p,a as n,b as a,d as e}from"./app-fe9da4b4.js";const c={},u={id:"_2-顶层的绑定会被暴露给模板",tabindex:"-1"},d={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#top-level-bindings-are-exposed-to-template",target:"_blank",rel:"noopener noreferrer"},k={id:"_3-响应式",tabindex:"-1"},v={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#reactivity",target:"_blank",rel:"noopener noreferrer"},g={href:"https://staging-cn.vuejs.org/api/reactivity-core.html",target:"_blank",rel:"noopener noreferrer"},m={id:"_4-使用组件",tabindex:"-1"},b={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#using-components",target:"_blank",rel:"noopener noreferrer"},f={id:"_4-1-动态组件",tabindex:"-1"},y={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#dynamic-components",target:"_blank",rel:"noopener noreferrer"},w={id:"_4-2-递归组件",tabindex:"-1"},j={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#recursive-components",target:"_blank",rel:"noopener noreferrer"},x={id:"_4-3-命名空间组件",tabindex:"-1"},h={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#namespaced-components",target:"_blank",rel:"noopener noreferrer"},P={id:"_6-defineprops-和-defineemits",tabindex:"-1"},E={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits",target:"_blank",rel:"noopener noreferrer"},F={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#typescript-only-features",target:"_blank",rel:"noopener noreferrer"},q={id:"_7-defineexpose",tabindex:"-1"},C={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#defineexpose",target:"_blank",rel:"noopener noreferrer"},S={id:"_8-useslots-和-useattrs",tabindex:"-1"},A={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#useslots-useattrs",target:"_blank",rel:"noopener noreferrer"},B={id:"_9-与普通的-script-一起使用",tabindex:"-1"},M={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#usage-alongside-normal-script",target:"_blank",rel:"noopener noreferrer"},I={id:"_10-顶层-await",tabindex:"-1"},D={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#top-level-await",target:"_blank",rel:"noopener noreferrer"},T={href:"https://staging-cn.vuejs.org/guide/built-ins/suspense.html",target:"_blank",rel:"noopener noreferrer"},N={id:"_11-针对-typescript-的功能",tabindex:"-1"},L={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#typescript-only-features",target:"_blank",rel:"noopener noreferrer"},V={id:"_11-1-针对类型的-props-emit-声明",tabindex:"-1"},O={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#type-only-propsemit-declarations",target:"_blank",rel:"noopener noreferrer"},$={id:"_11-2-使用类型声明时的默认-props-值",tabindex:"-1"},H={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#default-props-values-when-using-type-declaration",target:"_blank",rel:"noopener noreferrer"},J={id:"_12-限制",tabindex:"-1"},X={href:"https://staging-cn.vuejs.org/api/sfc-script-setup.html#restrictions",target:"_blank",rel:"noopener noreferrer"};function z(G,s){const t=l("ExternalLinkIcon");return i(),r("div",null,[s[70]||(s[70]=p(`<h1 id="_13-【script-setup-总结】" tabindex="-1"><a class="header-anchor" href="#_13-【script-setup-总结】" aria-hidden="true">#</a> 13 【script setup 总结】</h1><blockquote><p>因为学习的时候，视频版本并没有一些新的语法糖，笔记是没有使用这些语法糖的，但是用法都会以补充的形式加进来。</p></blockquote><p>在 <code>setup()</code> 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码。</p><p><code>&lt;script setup&gt; </code>是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。当同时使用 SFC 与组合式 API 时该语法是默认推荐。相比于普通的<code>&lt;script&gt;</code>语法，它具有更多优势：</p><ul><li>更少的样板内容，更简洁的代码。</li><li>能够使用纯 Typescript 声明 props 和自定义事件。</li><li>更好的运行时性能 (其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文代理对象)。</li><li>更好的 IDE 类型推导性能 (减少了语言服务器从代码中抽取类型的工作)。</li></ul><h2 id="_1-基本语法" tabindex="-1"><a class="header-anchor" href="#_1-基本语法" aria-hidden="true">#</a> 1.基本语法</h2><p>要启用该语法，需要在 <code>&lt;script&gt;</code> 代码块上添加 <code>setup</code> attribute：</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;hello script setup&#39;</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>里面的代码会被编译成组件 <code>setup()</code> 函数的内容。这意味着与普通的 <code>&lt;script&gt;</code> 只在组件被首次引入的时候执行一次不同，<code>&lt;script setup&gt;</code> 中的代码会在<strong>每次组件实例被创建的时候执行</strong>。</p>`,9)),n("h2",u,[s[1]||(s[1]=n("a",{class:"header-anchor",href:"#_2-顶层的绑定会被暴露给模板","aria-hidden":"true"},"#",-1)),s[2]||(s[2]=a(" 2.顶层的绑定会被暴露给模板")),n("a",d,[s[0]||(s[0]=a("#")),e(t)])]),s[71]||(s[71]=p(`<p>当使用 <code>&lt;script setup&gt;</code> 的时候，任何在 <code>&lt;script setup&gt;</code> 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用：</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token comment">// 变量</span>
<span class="token keyword">const</span> msg <span class="token operator">=</span> <span class="token string">&#39;Hello!&#39;</span>

<span class="token comment">// 函数</span>
<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>log<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ msg }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2)),n("h2",k,[s[4]||(s[4]=n("a",{class:"header-anchor",href:"#_3-响应式","aria-hidden":"true"},"#",-1)),s[5]||(s[5]=a(" 3.响应式")),n("a",v,[s[3]||(s[3]=a("#")),e(t)])]),n("p",null,[s[7]||(s[7]=a("响应式状态需要明确使用")),n("a",g,[s[6]||(s[6]=a("响应式 API")),e(t)]),s[8]||(s[8]=a(" 来创建。和 ")),s[9]||(s[9]=n("code",null,"setup()",-1)),s[10]||(s[10]=a(" 函数的返回值一样，ref 在模板中使用的时候会自动解包："))]),s[72]||(s[72]=p(`<div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>count++<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),n("h2",m,[s[12]||(s[12]=n("a",{class:"header-anchor",href:"#_4-使用组件","aria-hidden":"true"},"#",-1)),s[13]||(s[13]=a(" 4.使用组件")),n("a",b,[s[11]||(s[11]=a("#")),e(t)])]),s[73]||(s[73]=p(`<p><code>&lt;script setup&gt;</code> 范围里的值也能被直接作为自定义组件的标签名使用：</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> MyComponent <span class="token keyword">from</span> <span class="token string">&#39;./MyComponent.vue&#39;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> MyComponent <span class="token keyword">from</span> <span class="token string">&#39;./MyComponent.vue&#39;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MyComponent</span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 <code>MyComponent</code> 应当被理解为像是在引用一个变量。如果你使用过 JSX，此处的心智模型是类似的。其 kebab-case 格式的 <code>&lt;my-component&gt;</code> 同样能在模板中使用——不过，我们强烈建议使用 PascalCase 格式以保持一致性。同时这也有助于区分原生的自定义元素。</p>`,4)),n("h3",f,[s[15]||(s[15]=n("a",{class:"header-anchor",href:"#_4-1-动态组件","aria-hidden":"true"},"#",-1)),s[16]||(s[16]=a(" 4.1 动态组件")),n("a",y,[s[14]||(s[14]=a("#")),e(t)])]),s[74]||(s[74]=p(`<p>由于组件是通过变量引用而不是基于字符串组件名注册的，在 <code>&lt;script setup&gt;</code> 中要使用动态组件的时候，应该使用动态的 <code>:is</code> 来绑定：</p><div class="language-vue line-numbers-mode" data-ext="vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">import</span> Foo <span class="token keyword">from</span> <span class="token string">&#39;./Foo.vue&#39;</span>
<span class="token keyword">import</span> Bar <span class="token keyword">from</span> <span class="token string">&#39;./Bar.vue&#39;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>Foo<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name">:is</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>someCondition ? Foo : Bar<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意组件是如何在三元表达式中被当做变量使用的。</p>`,3)),n("h3",w,[s[18]||(s[18]=n("a",{class:"header-anchor",href:"#_4-2-递归组件","aria-hidden":"true"},"#",-1)),s[19]||(s[19]=a(" 4.2 递归组件")),n("a",j,[s[17]||(s[17]=a("#")),e(t)])]),s[75]||(s[75]=p(`<p>一个单文件组件可以通过它的文件名被其自己所引用。例如：名为 <code>FooBar.vue</code> 的组件可以在其模板中用 <code>&lt;FooBar/&gt;</code> 引用它自己。</p><p>请注意这种方式相比于导入的组件优先级更低。如果有具名的导入和组件自身推导的名字冲突了，可以为导入的组件添加别名：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> FooBar <span class="token keyword">as</span> FooBarChild <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./components&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3)),n("h3",x,[s[21]||(s[21]=n("a",{class:"header-anchor",href:"#_4-3-命名空间组件","aria-hidden":"true"},"#",-1)),s[22]||(s[22]=a(" 4.3 命名空间组件")),n("a",h,[s[20]||(s[20]=a("#")),e(t)])]),s[76]||(s[76]=p(`<p>可以使用带 <code>.</code> 的组件标签，例如 <code>&lt;Foo.Bar&gt;</code> 来引用嵌套在对象属性中的组件。这在需要从单个文件中导入多个组件的时候非常有用：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Form <span class="token keyword">from</span> <span class="token string">&#39;./form-components&#39;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>Form<span class="token punctuation">.</span>Input<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>Form<span class="token punctuation">.</span>Label<span class="token operator">&gt;</span>label<span class="token operator">&lt;</span><span class="token operator">/</span>Form<span class="token punctuation">.</span>Label<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>Form<span class="token punctuation">.</span>Input<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_5-使用自定义指令" tabindex="-1"><a class="header-anchor" href="#_5-使用自定义指令" aria-hidden="true">#</a> 5.使用自定义指令</h2><p>全局注册的自定义指令将正常工作。本地的自定义指令在 <code>&lt;script setup&gt;</code> 中不需要显式注册，但他们必须遵循 <code>vNameOfDirective</code> 这样的命名规范：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">const</span> vMyDirective <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">beforeMount</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在元素上做些操作</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>template<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>h1 v<span class="token operator">-</span>my<span class="token operator">-</span>directive<span class="token operator">&gt;</span>This is a Heading<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果指令是从别处导入的，可以通过重命名来使其符合命名规范：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> myDirective <span class="token keyword">as</span> vMyDirective <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./MyDirective.js&#39;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7)),n("h2",P,[s[24]||(s[24]=n("a",{class:"header-anchor",href:"#_6-defineprops-和-defineemits","aria-hidden":"true"},"#",-1)),s[25]||(s[25]=a(" 6.")),s[26]||(s[26]=n("code",null,"defineProps()",-1)),s[27]||(s[27]=a(" 和 ")),s[28]||(s[28]=n("code",null,"defineEmits()",-1)),n("a",E,[s[23]||(s[23]=a("#")),e(t)])]),s[77]||(s[77]=p(`<p>为了在声明 <code>props</code> 和 <code>emits</code> 选项时获得完整的类型推导支持，我们可以使用 <code>defineProps</code> 和 <code>defineEmits</code> API，它们将自动地在 <code>&lt;script setup&gt;</code> 中可用：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">defineProps</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> String
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token function">defineEmits</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;change&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;delete&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// setup 代码</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>defineProps</code> 和 <code>defineEmits</code> 都是只能在 <code>&lt;script setup&gt;</code> 中使用的<strong>编译器宏</strong>。他们不需要导入，且会随着 <code>&lt;script setup&gt;</code> 的处理过程一同被编译掉。</li><li><code>defineProps</code> 接收与 <code>props</code> 选项相同的值，<code>defineEmits</code> 接收与 <code>emits</code> 选项相同的值。</li><li><code>defineProps</code> 和 <code>defineEmits</code> 在选项传入后，会提供恰当的类型推导。</li><li>传入到 <code>defineProps</code> 和 <code>defineEmits</code> 的选项会从 setup 中提升到模块的作用域。因此，传入的选项不能引用在 setup 作用域中声明的局部变量。这样做会引起编译错误。但是，它<em>可以</em>引用导入的绑定，因为它们也在模块作用域内。</li></ul>`,3)),n("p",null,[s[30]||(s[30]=a("如果使用了 Typescript，")),n("a",F,[s[29]||(s[29]=a("使用纯类型声明来声明 prop 和 emit")),e(t)]),s[31]||(s[31]=a(" 也是可以的。"))]),n("h2",q,[s[33]||(s[33]=n("a",{class:"header-anchor",href:"#_7-defineexpose","aria-hidden":"true"},"#",-1)),s[34]||(s[34]=a(" 7.")),s[35]||(s[35]=n("code",null,"defineExpose",-1)),n("a",C,[s[32]||(s[32]=a("#")),e(t)])]),s[78]||(s[78]=p(`<p>使用 <code>&lt;script setup&gt;</code> 的组件是<strong>默认关闭</strong>的——即通过模板引用或者 <code>$parent</code> 链获取到的组件的公开实例，<strong>不会</strong>暴露任何在 <code>&lt;script setup&gt;</code> 中声明的绑定。</p><p>可以通过 <code>defineExpose</code> 编译器宏来显式指定在 <code>&lt;script setup&gt;</code> 组件中要暴露出去的属性：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>

<span class="token function">defineExpose</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  a<span class="token punctuation">,</span>
  b
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当父组件通过模板引用的方式获取到当前组件的实例，获取到的实例会像这样 <code>{ a: number, b: number }</code> (ref 会和在普通实例中一样被自动解包)</p>`,4)),n("h2",S,[s[37]||(s[37]=n("a",{class:"header-anchor",href:"#_8-useslots-和-useattrs","aria-hidden":"true"},"#",-1)),s[38]||(s[38]=a(" 8.")),s[39]||(s[39]=n("code",null,"useSlots()",-1)),s[40]||(s[40]=a(" 和 ")),s[41]||(s[41]=n("code",null,"useAttrs()",-1)),n("a",A,[s[36]||(s[36]=a("#")),e(t)])]),s[79]||(s[79]=p(`<p>在 <code>&lt;script setup&gt;</code> 使用 <code>slots</code> 和 <code>attrs</code> 的情况应该是相对来说较为罕见的，因为可以在模板中直接通过 <code>$slots</code> 和 <code>$attrs</code> 来访问它们。在你的确需要使用它们的罕见场景中，可以分别用 <code>useSlots</code> 和 <code>useAttrs</code> 两个辅助函数：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> useSlots<span class="token punctuation">,</span> useAttrs <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> slots <span class="token operator">=</span> <span class="token function">useSlots</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> attrs <span class="token operator">=</span> <span class="token function">useAttrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>useSlots</code> 和 <code>useAttrs</code> 是真实的运行时函数，它的返回与 <code>setupContext.slots</code> 和 <code>setupContext.attrs</code> 等价。它们同样也能在普通的组合式 API 中使用。</p>`,3)),n("h2",B,[s[43]||(s[43]=n("a",{class:"header-anchor",href:"#_9-与普通的-script-一起使用","aria-hidden":"true"},"#",-1)),s[44]||(s[44]=a(" 9.与普通的 ")),s[45]||(s[45]=n("code",null,"<script>",-1)),s[46]||(s[46]=a(" 一起使用")),n("a",M,[s[42]||(s[42]=a("#")),e(t)])]),s[80]||(s[80]=p(`<p><code>&lt;script setup&gt; </code>可以和普通的 <code>&lt;script&gt; </code>一起使用。普通的<code>&lt;script&gt;</code>在有这些需要的情况下或许会被使用到：</p><ul><li>声明无法在 <code>&lt;script setup&gt;</code> 中声明的选项，例如 <code>inheritAttrs</code> 或插件的自定义选项。</li><li>声明模块的具名导出 (named exports)。</li><li>运行只需要在模块作用域执行一次的副作用，或是创建单例对象。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
<span class="token comment">// 普通 &lt;script&gt;, 在模块作用域下执行 (仅一次)</span>
<span class="token function">runSideEffectOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 声明额外的选项</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">inheritAttrs</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token literal-property property">customOptions</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;App&quot;</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token comment">// 在 setup() 作用域中执行 (对每个实例皆如此)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3)),n("h2",I,[s[48]||(s[48]=n("a",{class:"header-anchor",href:"#_10-顶层-await","aria-hidden":"true"},"#",-1)),s[49]||(s[49]=a(" 10.顶层 ")),s[50]||(s[50]=n("code",null,"await",-1)),n("a",D,[s[47]||(s[47]=a("#")),e(t)])]),s[81]||(s[81]=p(`<p><code>&lt;script setup&gt; </code>中可以使用顶层<code> await</code>。结果代码会被编译成 <code>async setup()：</code></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script setup<span class="token operator">&gt;</span>
<span class="token keyword">const</span> post <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">/api/post/1</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">r</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> r<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，await 的表达式会自动编译成在 <code>await</code> 之后保留当前组件实例上下文的格式。</p><p>注意</p>`,4)),n("p",null,[s[53]||(s[53]=n("code",null,"async setup()",-1)),s[54]||(s[54]=a(" 必须与 ")),n("a",T,[s[51]||(s[51]=n("code",null,"Suspense",-1)),s[52]||(s[52]=a(" 内置组件")),e(t)]),s[55]||(s[55]=a(" 组合使用，")),s[56]||(s[56]=n("code",null,"Suspense",-1)),s[57]||(s[57]=a(" 目前还是处于实验阶段的特性，会在将来的版本中稳定。"))]),n("h2",N,[s[59]||(s[59]=n("a",{class:"header-anchor",href:"#_11-针对-typescript-的功能","aria-hidden":"true"},"#",-1)),s[60]||(s[60]=a(" 11.针对 TypeScript 的功能")),n("a",L,[s[58]||(s[58]=a("#")),e(t)])]),n("h3",V,[s[62]||(s[62]=n("a",{class:"header-anchor",href:"#_11-1-针对类型的-props-emit-声明","aria-hidden":"true"},"#",-1)),s[63]||(s[63]=a(" 11.1 针对类型的 props/emit 声明")),n("a",O,[s[61]||(s[61]=a("#")),e(t)])]),s[82]||(s[82]=p(`<p>props 和 emit 都可以通过给 <code>defineProps</code> 和 <code>defineEmits</code> 传递纯类型参数的方式来声明：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span>
  bar<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> emit <span class="token operator">=</span> <span class="token generic-function"><span class="token function">defineEmits</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token punctuation">{</span>
  <span class="token punctuation">(</span>e<span class="token operator">:</span> <span class="token string">&#39;change&#39;</span><span class="token punctuation">,</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
  <span class="token punctuation">(</span>e<span class="token operator">:</span> <span class="token string">&#39;update&#39;</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>defineProps</code> 或 <code>defineEmits</code> 只能要么使用运行时声明，要么使用类型声明。同时使用两种声明方式会导致编译报错。</p></li><li><p>使用类型声明的时候，静态分析会自动生成等效的运行时声明，从而在避免双重声明的前提下确保正确的运行时行为。</p><ul><li>在开发模式下，编译器会试着从类型来推导对应的运行时验证。例如这里从 <code>foo: string</code> 类型中推断出 <code>foo: String</code>。如果类型是对导入类型的引用，这里的推导结果会是 <code>foo: null</code> (与 <code>any</code> 类型相等)，因为编译器没有外部文件的信息。</li><li>在生产模式下，编译器会生成数组格式的声明来减少打包体积 (这里的 props 会被编译成 <code>[&#39;foo&#39;, &#39;bar&#39;]</code>)。</li><li>生成的代码仍然是有着合法类型的 Typescript 代码，它可以在后续的流程中被其他工具处理。</li></ul></li><li><p>截至目前，类型声明参数必须是以下内容之一，以确保正确的静态分析：</p><ul><li>类型字面量</li><li>在同一文件中的接口或类型字面量的引用</li></ul><p>现在还不支持复杂的类型和从其他文件进行类型导入，但我们有计划在将来支持。</p></li></ul>`,3)),n("h3",$,[s[65]||(s[65]=n("a",{class:"header-anchor",href:"#_11-2-使用类型声明时的默认-props-值","aria-hidden":"true"},"#",-1)),s[66]||(s[66]=a(" 11.2 使用类型声明时的默认 props 值")),n("a",H,[s[64]||(s[64]=a("#")),e(t)])]),s[83]||(s[83]=p(`<p>针对类型的 <code>defineProps</code> 声明的不足之处在于，它没有可以给 props 提供默认值的方式。为了解决这个问题，我们还提供了 <code>withDefaults</code> 编译器宏：</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>
  msg<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>
  labels<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> props <span class="token operator">=</span> <span class="token function">withDefaults</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">defineProps</span><span class="token generic class-name"><span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  msg<span class="token operator">:</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">,</span>
  <span class="token function-variable function">labels</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string">&#39;one&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;two&#39;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码会被编译为等价的运行时 props 的 <code>default</code> 选项。此外，<code>withDefaults</code> 辅助函数提供了对默认值的类型检查，并确保返回的 <code>props</code> 的类型删除了已声明默认值的属性的可选标志。</p>`,3)),n("h2",J,[s[68]||(s[68]=n("a",{class:"header-anchor",href:"#_12-限制","aria-hidden":"true"},"#",-1)),s[69]||(s[69]=a(" 12.限制")),n("a",X,[s[67]||(s[67]=a("#")),e(t)])]),s[84]||(s[84]=n("p",null,[a("由于模块执行语义的差异，"),n("code",null,"<script setup>"),a(" 中的代码依赖单文件组件的上下文。当将其移动到外部的 "),n("code",null,".js"),a(" 或者 "),n("code",null,".ts"),a(" 文件中的时候，对于开发者和工具来说都会感到混乱。因此，"),n("strong",null,[n("code",null,"<script setup>")]),a(" 不能和 "),n("code",null,"src"),a(" attribute 一起使用。")],-1))])}const R=o(c,[["render",z],["__file","13.html.vue"]]);export{R as default};
